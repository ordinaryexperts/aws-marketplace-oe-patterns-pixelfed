import os
import subprocess

from aws_cdk import (
    Aws,
    aws_iam,
    CfnMapping,
    CfnOutput,
    CfnParameter,
    Stack
)
from constructs import Construct

from oe_patterns_cdk_common.alb import Alb
from oe_patterns_cdk_common.asg import Asg
from oe_patterns_cdk_common.assets_bucket import AssetsBucket
from oe_patterns_cdk_common.aurora_cluster import AuroraMysql
from oe_patterns_cdk_common.db_secret import DbSecret
from oe_patterns_cdk_common.dns import Dns
from oe_patterns_cdk_common.elasticache_cluster import ElasticacheRedis
from oe_patterns_cdk_common.ses import Ses
from oe_patterns_cdk_common.util import Util
from oe_patterns_cdk_common.vpc import Vpc

if 'TEMPLATE_VERSION' in os.environ:
    template_version = os.environ['TEMPLATE_VERSION']
else:
    try:
        template_version = subprocess.check_output(["git", "describe", "--always"]).strip().decode('ascii')
    except:
        template_version = "CICD"

# AMI list generated by:
# make TEMPLATE_VERSION=1.1.0 ami-ec2-build
# on Fri Oct  6 05:44:56 UTC 2023.
AMI_ID="ami-0c1b592906ca98183"
AMI_NAME="ordinary-experts-patterns-pixelfed-1.1.0-20231006-0534"
generated_ami_ids = {
    "us-east-2": "ami-XXXXXXXXXXXXXXXXX",
    "us-west-1": "ami-XXXXXXXXXXXXXXXXX",
    "us-west-2": "ami-XXXXXXXXXXXXXXXXX",
    "ca-central-1": "ami-XXXXXXXXXXXXXXXXX",
    "eu-central-1": "ami-XXXXXXXXXXXXXXXXX",
    "eu-central-2": "ami-XXXXXXXXXXXXXXXXX",
    "eu-west-1": "ami-XXXXXXXXXXXXXXXXX",
    "eu-west-2": "ami-XXXXXXXXXXXXXXXXX",
    "eu-west-3": "ami-XXXXXXXXXXXXXXXXX",
    "eu-north-1": "ami-XXXXXXXXXXXXXXXXX",
    "eu-south-1": "ami-XXXXXXXXXXXXXXXXX",
    "eu-south-2": "ami-XXXXXXXXXXXXXXXXX",
    "af-south-1": "ami-XXXXXXXXXXXXXXXXX",
    "ap-southeast-1": "ami-XXXXXXXXXXXXXXXXX",
    "ap-southeast-2": "ami-XXXXXXXXXXXXXXXXX",
    "ap-southeast-3": "ami-XXXXXXXXXXXXXXXXX",
    "ap-southeast-4": "ami-XXXXXXXXXXXXXXXXX",
    "ap-south-1": "ami-XXXXXXXXXXXXXXXXX",
    "ap-south-2": "ami-XXXXXXXXXXXXXXXXX",
    "ap-northeast-1": "ami-XXXXXXXXXXXXXXXXX",
    "ap-northeast-2": "ami-XXXXXXXXXXXXXXXXX",
    "ap-northeast-3": "ami-XXXXXXXXXXXXXXXXX",
    "ap-east-1": "ami-XXXXXXXXXXXXXXXXX",
    "sa-east-1": "ami-XXXXXXXXXXXXXXXXX",
    "me-south-1": "ami-XXXXXXXXXXXXXXXXX",
    "me-central-1": "ami-XXXXXXXXXXXXXXXXX",
    "us-east-1": "ami-0c1b592906ca98183"
}
# End generated code block.

class PixelfedStack(Stack):

    def __init__(self, scope: Construct, construct_id: str, **kwargs) -> None:
        super().__init__(scope, construct_id, **kwargs)

        # vpc
        vpc = Vpc(
            self,
            "Vpc"
        )

        self.name_param = CfnParameter(
            self,
            "Name",
            default="Pixelfed",
            description="Required: The name of this Pixelfed site."
        )

        self.activity_pub_enabled_param = CfnParameter(
            self,
            "ActivityPubEnabled",
            default="true",
            description="Optional: Whether to enable ActivityPub for this instance.",
            allowed_values=["true", "false"]
        )

        self.login_with_mastodon_enabled_param = CfnParameter(
            self,
            "MastodonLoginEnabled",
            default="false",
            description="Optional: Whether to enable login with Mastodon for this instance.",
            allowed_values=["true", "false"]
        )

        self.login_with_mastodon_skip_email_param = CfnParameter(
            self,
            "MastodonLoginSkipEmailVerification",
            default="true",
            description="Optional: To improve the onboarding experience, you can opt to skip the email verification process and automatically verify their email.",
            allowed_values=["true", "false"]
        )

        self.login_with_mastodon_domains_param = CfnParameter(
            self,
            "MastodonLoginCustomDomains",
            default="",
            description="Optional: Comma separated list of custom domains to allow."
        )

        self.login_with_mastodon_only_default_param = CfnParameter(
            self,
            "MastodonLoginOnlyDefaultDomains",
            default="true",
            description="Optional: Allow Sign-in with Mastodon using only the default domains.",
            allowed_values=["true", "false"]
        )

        self.login_with_mastodon_only_custom_param = CfnParameter(
            self,
            "MastodonLoginOnlyCustomDomains",
            default="false",
            description="Optional: Allow Sign-in with Mastodon using only the custom domains you define, in comma separated format.",
            allowed_values=["true", "false"]
        )

        self.login_with_mastodon_enforce_max_uses_param = CfnParameter(
            self,
            "MastodonLoginEnforceMaxUses",
            default="false",
            description="Optional: Using a centralized service operated by pixelfed.org that tracks mastodon imports, you can set a limit of how many times a mastodon account can be imported across all known and reporting Pixelfed instances to prevent the same masto account from abusing this.",
            allowed_values=["true", "false"]
        )

        self.login_with_mastodon_max_uses_limit_param = CfnParameter(
            self,
            "MastodonLoginMaxUsesLimit",
            default="3",
            description="Optional: Integer limit of how many times a Mastodon account can be imported accross all known and reporting Pixelfed instances."
        )

        # dns
        dns = Dns(self, "Dns")

        bucket = AssetsBucket(
            self,
            "AssetsBucket",
            allow_open_cors = True,
            object_ownership_value = "ObjectWriter",
            remove_public_access_block = True
        )

        ses = Ses(
            self,
            "Ses",
            hosted_zone_name=dns.route_53_hosted_zone_name_param.value_as_string,
            additional_iam_user_policies=[bucket.user_policy]
        )

        # db_secret
        db_secret = DbSecret(
            self,
            "DbSecret",
            username = 'pixelfed'
        )

        # redis
        redis = ElasticacheRedis(
            self,
            "Redis",
            vpc=vpc
        )

        asg_update_secret_policy = aws_iam.CfnRole.PolicyProperty(
            policy_document=aws_iam.PolicyDocument(
                statements=[
                    aws_iam.PolicyStatement(
                        effect=aws_iam.Effect.ALLOW,
                        actions=[
                            "secretsmanager:UpdateSecret"
                        ],
                        resources=[
                            f"arn:{Aws.PARTITION}:secretsmanager:{Aws.REGION}:{Aws.ACCOUNT_ID}:secret:{Aws.STACK_NAME}/instance/credentials-*"
                        ]
                    )
                ]
            ),
            policy_name="AllowUpdateInstanceSecret"
        )

        # asg
        with open("pixelfed/user_data.sh") as f:
            user_data_contents = f.read()
        asg = Asg(
            self,
            "Asg",
            additional_iam_role_policies=[asg_update_secret_policy],
            default_instance_type="t3.small",
            secret_arns=[db_secret.secret_arn(), ses.secret_arn()],
            singleton = True,
            use_data_volume = True,
            use_graviton = False,
            user_data_contents=user_data_contents,
            user_data_variables={
                "AppName": self.name_param.value_as_string,
                "AssetsBucketName": bucket.bucket_name(),
                "DbSecretArn": db_secret.secret_arn(),
                "Hostname": dns.hostname(),
                "HostedZoneName": dns.route_53_hosted_zone_name_param.value_as_string,
                "InstanceSecretName": Aws.STACK_NAME + "/instance/credentials"
            },
            vpc=vpc
        )

        ami_mapping={ "AMI": { "OEAMI": AMI_NAME } }
        for region in generated_ami_ids.keys():
            ami_mapping[region] = { "AMI": generated_ami_ids[region] }
        aws_ami_region_map = CfnMapping(
            self,
            "AWSAMIRegionMap",
            mapping=ami_mapping
        )

        alb = Alb(
            self,
            "Alb",
            asg=asg,
            health_check_path = "/api/service/health-check",
            vpc=vpc
        )

        asg.asg.target_group_arns = [ alb.target_group.ref ]

        db = AuroraMysql(
            self,
            "Db",
            database_name="pixelfed",
            db_secret=db_secret,
            vpc=vpc
        )
        asg.asg.node.add_dependency(db.db_primary_instance)
        asg.asg.node.add_dependency(ses.generate_smtp_password_custom_resource)

        redis_ingress = Util.add_sg_ingress(redis, asg.sg)
        db_ingress    = Util.add_sg_ingress(db, asg.sg)
        
        dns.add_alb(alb)

        CfnOutput(
            self,
            "FirstUseInstructions",
            description="Instructions for getting started",
            value="Click on the DnsSiteUrlOutput link and register a new user. Then you can make that user an admin with the following command run as root: 'cd /usr/share/webapps/pixelfed && php artisan user:admin username_here && php artisan cache:clear' on the instance after logging in with SSM Sessions Manager. See more here: https://docs.pixelfed.org/running-pixelfed/administration/"
        )

        parameter_groups = [
            {
                "Label": {
                    "default": "Application Config"
                },
                "Parameters": [
                    self.name_param.logical_id,
                    self.activity_pub_enabled_param.logical_id
                ]
            },
            {
                "Label": {
                    "default": "Mastodon Login Config"
                },
                "Parameters": [
                    self.login_with_mastodon_enabled_param.logical_id,
                    self.login_with_mastodon_skip_email_param.logical_id,
                    self.login_with_mastodon_domains_param.logical_id,
                    self.login_with_mastodon_only_default_param.logical_id,
                    self.login_with_mastodon_only_custom_param.logical_id,
                    self.login_with_mastodon_enforce_max_uses_param.logical_id,
                    self.login_with_mastodon_max_uses_limit_param.logical_id
                ]
            }
        ]
        parameter_groups += alb.metadata_parameter_group()
        parameter_groups += bucket.metadata_parameter_group()
        parameter_groups += db_secret.metadata_parameter_group()
        parameter_groups += db.metadata_parameter_group()
        parameter_groups += dns.metadata_parameter_group()
        parameter_groups += redis.metadata_parameter_group()
        parameter_groups += asg.metadata_parameter_group()
        parameter_groups += ses.metadata_parameter_group()
        parameter_groups += vpc.metadata_parameter_group()

        # AWS::CloudFormation::Interface
        self.template_options.metadata = {
            "OE::Patterns::TemplateVersion": template_version,
            "AWS::CloudFormation::Interface": {
                "ParameterGroups": parameter_groups,
                "ParameterLabels": {
                    self.name_param.logical_id: {
                        "default": "Pixelfed Site Name"
                    },
                    self.activity_pub_enabled_param.logical_id: {
                        "default": "Enable ActivityPub"
                    },
                    self.login_with_mastodon_enabled_param.logical_id: {
                        "default": "Enable Mastodon Login"
                    },
                    self.login_with_mastodon_skip_email_param.logical_id: {
                        "default": "Mastodon Login - Skip Email Verification"
                    },
                    self.login_with_mastodon_domains_param.logical_id: {
                        "default": "Mastodon Login - Custom Domains"
                    },
                    self.login_with_mastodon_only_default_param.logical_id: {
                        "default": "Mastodon Login - Only Default Domains"
                    },
                    self.login_with_mastodon_only_custom_param.logical_id: {
                        "default": "Mastodon Login - Only Custom Domains"
                    },
                    self.login_with_mastodon_enforce_max_uses_param.logical_id: {
                        "default": "Mastodon Login - Enforce Max Uses"
                    },
                    self.login_with_mastodon_max_uses_limit_param.logical_id: {
                        "default": "Mastodon Login - Max Uses Limit"
                    },
                    **alb.metadata_parameter_labels(),
                    **bucket.metadata_parameter_labels(),
                    **db_secret.metadata_parameter_labels(),
                    **db.metadata_parameter_labels(),
                    **dns.metadata_parameter_labels(),
                    **redis.metadata_parameter_labels(),
                    **asg.metadata_parameter_labels(),
                    **ses.metadata_parameter_labels(),
                    **vpc.metadata_parameter_labels()
                }
            }
        }
